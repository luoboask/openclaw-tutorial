# OpenClaw 记忆系统技术详解

OpenClaw 的记忆系统是其核心特性之一，它让 AI 助手能够记住对话历史、学习用户偏好，并在多次会话之间保持上下文连贯性。本文将深入解析记忆系统的架构设计和技术实现。

## 记忆系统的核心组件

### 1. 会话记忆 (Session Memory)

每个对话会话都有独立的记忆空间，包括：

- **消息历史**：完整的对话记录，用于上下文理解
- **工具调用记录**：之前执行过的工具及其结果
- **临时状态**：当前任务的中间状态

```typescript
// 会话记忆结构示例
interface SessionMemory {
  sessionId: string;
  messages: Message[];
  toolCalls: ToolCall[];
  metadata: SessionMetadata;
}
```

### 2. 长期记忆 (Long-term Memory)

跨会话的记忆存储，包括：

- **用户偏好**：用户常用的命令、喜欢的方式
- **重要信息**：用户特意让记住的内容
- **学习到的模式**：从对话中提取的知识

### 3. 向量记忆 (Vector Memory)

使用向量数据库存储语义记忆：

- **文档嵌入**：将文档转换为向量表示
- **语义搜索**：基于含义而非关键词的检索
- **相似度匹配**：找到相关的历史信息

## 技术架构

### 存储层

```
┌─────────────────────────────────────────────┐
│              Memory Storage                 │
├─────────────────────────────────────────────┤
│  SQLite    │   Vector DB    │   File       │
│  (关系)    │   (语义)       │   (原始)     │
├────────────┼────────────────┼──────────────┤
│  会话元数据 │   文档嵌入     │   大文件     │
│  结构化数据 │   语义索引     │   附件       │
└─────────────────────────────────────────────┘
```

### 检索机制

OpenClaw 使用多路召回策略：

1. **关键词搜索 (BM25)**
   - 基于词频和逆文档频率
   - 适合精确匹配

2. **向量相似度搜索**
   - 基于语义嵌入
   - 适合概念相关的内容

3. **全文搜索 (FTS)**
   - 数据库级别的文本索引
   - 高性能大文本检索

## 记忆管理策略

### 自动压缩

长期记忆会自动压缩和总结：

```python
# 伪代码示例
class MemoryCompressor:
    def compress(self, old_memories, threshold=30):
        """当记忆超过阈值天数时进行压缩"""
        for memory in old_memories:
            if memory.age > threshold:
                summary = self.summarize(memory.content)
                memory.content = summary
                memory.is_compressed = True
```

### 重要性评分

每条记忆都有重要性评分：

- **High**：用户明确说"记住这个"
- **Medium**：提取的关键信息
- **Low**：普通的对话内容

系统优先保留高重要性记忆，定期清理低重要性内容。

## 实际应用场景

### 场景 1：项目管理助手

```
用户：记住我在做一个叫 "OpenClaw 网站" 的项目
Agent：[保存到长期记忆]

三天后...
用户：那个项目怎么样了？
Agent：你说的是 "OpenClaw 网站" 项目吗？根据记录...
```

### 场景 2：代码助手

```
用户：我喜欢用 TypeScript 而不是 JavaScript
Agent：[记录偏好]

之后生成代码时...
Agent：基于你之前的偏好，我用 TypeScript 来写...
```

### 场景 3：个人助理

```
用户：我每周五下午 3 点有团队例会
Agent：[提取并存储结构化信息]

每周五上午...
Agent：提醒：今天下午 3 点有团队例会
```

## 配置文件

在 `config.yaml` 中配置记忆系统：

```yaml
memory:
  enabled: true
  
  # 会话记忆
  session:
    max_messages: 50        # 单会话最大消息数
    context_window: 16000   # 上下文窗口大小
  
  # 长期记忆
  long_term:
    storage_path: ./memory
    auto_compress_days: 30  # 自动压缩天数
    importance_threshold: 0.5
  
  # 向量记忆
  vector:
    enabled: true
    model: text-embedding-3-small
    dimensions: 1536
    similarity_threshold: 0.7
```

## 最佳实践

### 1. 明确指令

告诉 Agent 什么是重要的：

- ✅ "记住这个，很重要"
- ✅ "记住我的 API Key"
- ❌ 期待 Agent 自动判断所有事情的重要性

### 2. 定期整理

- 每周回顾一次 MEMORY.md
- 删除过时的信息
- 更新变化的内容

### 3. 分类存储

使用不同的文件分类记忆：

```
memory/
├── personal/          # 个人信息
├── projects/          # 项目相关
├── preferences/       # 偏好设置
├── daily/            # 每日记录
└── learnings/        # 学习笔记
```

## 性能优化

### 检索优化

- **索引策略**：为常用查询字段建立索引
- **缓存机制**：热点数据内存缓存
- **分片存储**：大数据量时分片处理

### 存储优化

- **压缩存储**：文本使用 gzip 压缩
- **定期归档**：旧数据归档到冷存储
- **增量更新**：只存储变化的部分

## 常见问题

**Q: 记忆会占用多少存储空间？**

A: 取决于使用频率，一般每月 10-50MB。可以配置自动清理策略。

**Q: 敏感信息如何保护？**

A: 可以配置加密存储，或者将敏感信息标记为不在记忆中存储。

**Q: 如何清除特定记忆？**

A: 直接告诉 Agent "忘记 XXX"，或者手动编辑记忆文件。

**Q: 记忆系统支持哪些数据库？**

A: 默认使用 SQLite，也支持 PostgreSQL、ChromaDB 等。

## 总结

OpenClaw 的记忆系统通过多层架构（会话记忆、长期记忆、向量记忆）和智能检索机制，为 AI 助手提供了强大的记忆能力。合理配置和使用记忆系统，可以显著提升助手的实用性和个性化程度。

记忆系统的核心设计哲学是：**记住该记住的，忘记该忘记的，在需要时准确回忆**。这让 AI 助手既能保持上下文的连贯性，又不会因为信息过载而影响性能。
